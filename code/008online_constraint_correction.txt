function online_constraint_correction()
    %% ====================== Experiment 1: Sliding Window Parameter Estimation ======================
    friction_experiment();
    
    %% ====================== Experiment 2: Dynamic Constraint Violation Suppression ======================
    constraint_violation_experiment();
    
    %% ====================== Experiment 3: Machine Vision Platform Integration Validation ======================
    vision_system_validation();
end

%% ====================== Experiment 1: Sliding Window Parameter Estimation ======================
function friction_experiment()
    % Parameter initialization
    params = struct();
    params.window_size = 30;      % Sliding window size
    params.alpha = 0.05;         % Learning rate
    params.real_friction = 0.12;  % Initial friction coefficient
    params.disturbance_time = 30; % Disturbance application time(s)
    params.disturbance_value = 0.02; % Friction coefficient increment
    
    % Simulation settings
    t = 0:0.1:60; % 0 to 60 seconds, step size 0.1s
    num_steps = length(t);
    
    % Preallocate storage
    friction_est = zeros(1, num_steps);
    friction_true = zeros(1, num_steps);
    error = zeros(1, num_steps);
    
    % Initial estimation
    friction_est(1) = 0.10; % Initial estimate
    
    % Gradient projection algorithm
    for i = 2:num_steps
        % Apply disturbance
        if t(i) >= params.disturbance_time
            params.real_friction = 0.12 + params.disturbance_value;
        end
        
        % Record true value
        friction_true(i) = params.real_friction;
        
        % Generate observation data (with noise)
        observation = params.real_friction + 0.01*randn();
        
        % Sliding window update
        if i <= params.window_size
            window_data = observation;
        else
            window_data = friction_est(i-params.window_size:i-1);
        end
        
        % Gradient calculation
        gradient = mean(window_data) - friction_est(i-1);
        
        % Parameter update (with projection)
        friction_est(i) = friction_est(i-1) + params.alpha * gradient;
        
        % Ensure parameters are within physical range
        friction_est(i) = max(0.08, min(0.20, friction_est(i)));
        
        % Calculate relative error
        error(i) = abs(friction_est(i) - friction_true(i)) / friction_true(i) * 100;
    end
    
    % Result visualization
    figure('Name', 'Friction Coefficient Estimation', 'Position', [100, 100, 800, 600]);
    
    % Friction coefficient estimation curve
    subplot(2,1,1);
    plot(t, friction_true, 'b-', 'LineWidth', 2); hold on;
    plot(t, friction_est, 'r--', 'LineWidth', 2);
    plot([params.disturbance_time, params.disturbance_time], ylim, 'k--', 'LineWidth', 1.5);
    title('Friction Coefficient Estimation');
    xlabel('Time(s)');
    ylabel('Friction Coefficient');
    legend('True Value', 'Estimated Value', 'Disturbance Time');
    grid on;
    
    % Relative error curve
    subplot(2,1,2);
    plot(t, error, 'm-', 'LineWidth', 2);
    hold on;
    yline(5, 'k--', 'LineWidth', 1.5); % 5% error line
    plot([params.disturbance_time, params.disturbance_time], ylim, 'k--', 'LineWidth', 1.5);
    title('Estimation Relative Error');
    xlabel('Time(s)');
    ylabel('Relative Error(%)');
    grid on;
    
    % Display key point data
    fprintf('=== Friction Coefficient Estimation Results ===\n');
    fprintf('Time(s)\tTrue Value\tEstimated Value\tRelative Error\n');
    idx = [1, find(t>=30,1), find(t>=60,1)];
    for i = idx
        fprintf('%.1f\t%.3f\t%.3f\t%.1f%%\n', t(i), friction_true(i), friction_est(i), error(i));
    end
end

%% ====================== Experiment 2: Dynamic Constraint Violation Suppression ======================
function constraint_violation_experiment()
    % Parameter initialization
    params = struct();
    params.simulation_time = 120; % Total simulation time(s)
    params.disturbance_time = 30; % Disturbance start time(s)
    params.light_decay_rate = 0.02; % Light source decay rate(per second)
    params.correction_start = 60; % Correction mechanism start time(s)
    
    % Time settings
    t = 0:0.5:params.simulation_time;
    num_steps = length(t);
    
    % Preallocate storage
    violation_rate = zeros(1, num_steps);
    max_violation = zeros(1, num_steps);
    light_intensity = ones(1, num_steps); % Normalized light intensity
    
    % Light source decay simulation
    for i = 2:num_steps
        if t(i) >= params.disturbance_time
            light_intensity(i) = light_intensity(i-1) * (1 - params.light_decay_rate);
        else
            light_intensity(i) = light_intensity(i-1);
        end
    end
    
    % Constraint violation rate simulation
    for i = 1:num_steps
        % Base violation rate (related to light intensity)
        base_rate = 0.15 * (1 - light_intensity(i));
        
        % Random fluctuation
        random_component = 0.05 * randn();
        
        % Total violation rate
        violation_rate(i) = max(0, min(1, base_rate + random_component));
        
        % Maximum violation rate (simulating peaks)
        if mod(i, 20) == 0
            max_violation(i) = min(1, violation_rate(i) + 0.15 * rand());
        else
            max_violation(i) = violation_rate(i);
        end
    end
    
    % Online correction mechanism (activated after 60 seconds)
    for i = find(t >= params.correction_start)
        % Correction effect - violation rate decreases over time
        decay_factor = exp(-0.05 * (t(i) - params.correction_start));
        violation_rate(i) = violation_rate(i) * decay_factor;
        max_violation(i) = max_violation(i) * decay_factor;
    end
    
    % Result visualization
    figure('Name', 'Dynamic Constraint Violation Suppression', 'Position', [100, 100, 1000, 800]);
    
    % Light intensity decay curve
    subplot(3,1,1);
    plot(t, light_intensity, 'b-', 'LineWidth', 2);
    hold on;
    plot([params.disturbance_time, params.disturbance_time], ylim, 'k--', 'LineWidth', 1.5);
    plot([params.correction_start, params.correction_start], ylim, 'g--', 'LineWidth', 1.5);
    title('Light Intensity Decay');
    xlabel('Time(s)');
    ylabel('Normalized Light Intensity');
    legend('Intensity', 'Disturbance Start', 'Correction Start');
    grid on;
    
    % Average violation rate
    subplot(3,1,2);
    plot(t, violation_rate*100, 'r-', 'LineWidth', 2);
    hold on;
    plot([params.disturbance_time, params.disturbance_time], ylim, 'k--', 'LineWidth', 1.5);
    plot([params.correction_start, params.correction_start], ylim, 'g--', 'LineWidth', 1.5);
    title('Average Constraint Violation Rate');
    xlabel('Time(s)');
    ylabel('Violation Rate(%)');
    grid on;
    
    % Maximum violation rate
    subplot(3,1,3);
    plot(t, max_violation*100, 'm-', 'LineWidth', 2);
    hold on;
    plot([params.disturbance_time, params.disturbance_time], ylim, 'k--', 'LineWidth', 1.5);
    plot([params.correction_start, params.correction_start], ylim, 'g--', 'LineWidth', 1.5);
    title('Maximum Constraint Violation Rate');
    xlabel('Time(s)');
    ylabel('Violation Rate(%)');
    grid on;
    
    % Phase analysis
    idx_initial = t >= params.disturbance_time & t < params.correction_start;
    idx_corrected = t >= params.correction_start;
    
    avg_violation_initial = mean(violation_rate(idx_initial)) * 100;
    max_violation_initial = max(max_violation(idx_initial)) * 100;
    
    avg_violation_corrected = mean(violation_rate(idx_corrected)) * 100;
    max_violation_corrected = max(max_violation(idx_corrected)) * 100;
    
    % Display results
    fprintf('\n=== Dynamic Constraint Violation Suppression Results ===\n');
    fprintf('Phase\t\tAverage Violation Rate\tMaximum Violation Rate\n');
    fprintf('Initial Disturbance\t%.1f%%\t\t%.1f%%\n', avg_violation_initial, max_violation_initial);
    fprintf('After Correction\t%.1f%%\t\t%.1f%%\n', avg_violation_corrected, max_violation_corrected);
    fprintf('Suppression Effect\t%.1f%%\t\t%.1f%%\n',...
            avg_violation_initial - avg_violation_corrected,...
            max_violation_initial - max_violation_corrected);
end

%% ====================== Experiment 3: Machine Vision Platform Integration Validation ======================
function vision_system_validation()
    % Parameter initialization
    params = struct();
    params.num_samples = 1000;     % Number of samples
    params.defect_rate = 0.10;    % Defect rate
    params.base_detection = 0.885; % Base detection rate
    
    % Fixed parameter mode
    fixed_params = struct();
    fixed_params.exposure = 500;  % Fixed exposure time(μs)
    fixed_params.light = 100;     % Fixed light source intensity(%)
    
    % Adaptive parameter mode
    adaptive_params = struct();
    adaptive_params.window_size = 50; % Sliding window size
    adaptive_params.learning_rate = 0.1; % Learning rate
    
    % Simulated data generation
    defects = rand(params.num_samples, 1) < params.defect_rate;
    
    % Fixed parameter mode performance
    fixed_results = simulate_vision_system(defects, fixed_params, false, params.base_detection);
    
    % Adaptive parameter mode performance
    adaptive_results = simulate_vision_system(defects, adaptive_params, true, params.base_detection);
    
    % Performance comparison
    metrics = {'Defect Detection Rate', 'Over/Under Exposure Rate', 'Average Processing Cycle'};
    fixed_values = [fixed_results.detection_rate*100,...
                   fixed_results.exposure_issues*100,...
                   fixed_results.processing_time];
               
    adaptive_values = [adaptive_results.detection_rate*100,...
                      adaptive_results.exposure_issues*100,...
                      adaptive_results.processing_time];
                  
    improvement = adaptive_values - fixed_values;
    improvement_rate = improvement ./ fixed_values * 100;
    
    % Result visualization
    figure('Name', 'Machine Vision Platform Performance Comparison', 'Position', [100, 100, 1000, 600]);
    
    % Performance metrics comparison
    subplot(2,1,1);
    bar_matrix = [fixed_values; adaptive_values]';
    bar(bar_matrix);
    set(gca, 'XTickLabel', metrics);
    ylabel('Performance Value');
    title('Fixed Parameters vs Adaptive Parameters');
    legend('Fixed Parameters', 'Adaptive Parameters');
    grid on;
    
    % Add data labels
    for i = 1:length(metrics)
        text(i-0.2, fixed_values(i)+2, sprintf('%.1f', fixed_values(i)), 'HorizontalAlignment', 'center');
        text(i+0.2, adaptive_values(i)+2, sprintf('%.1f', adaptive_values(i)), 'HorizontalAlignment', 'center');
    end
    
    % Performance improvement rate
    subplot(2,1,2);
    bar(improvement_rate);
    set(gca, 'XTickLabel', metrics);
    ylabel('Improvement Rate(%)');
    title('Performance Improvement Rate');
    grid on;
    
    % Add data labels
    for i = 1:length(metrics)
        text(i, improvement_rate(i), sprintf('%.1f%%', improvement_rate(i)),...
             'HorizontalAlignment', 'center', 'VerticalAlignment', 'bottom');
    end
    
    % Display results
    fprintf('\n=== Machine Vision Platform Integration Validation Results ===\n');
    fprintf('Metric\t\tFixed Parameters\tAdaptive Correction\tImprovement Rate\n');
    fprintf('Defect Detection Rate\t%.1f%%\t%.1f%%\t+%.1f%%\n',...
            fixed_values(1), adaptive_values(1), improvement_rate(1));
    fprintf('Over/Under Exposure Rate\t%.1f%%\t%.1f%%\t%.1f%%\n',...
            fixed_values(2), adaptive_values(2), improvement_rate(2));
    fprintf('Average Processing Cycle\t%.2fs\t%.2fs\t%.1f%%\n',...
            fixed_values(3), adaptive_values(3), improvement_rate(3));
end

%% ====================== Vision System Simulation Function ======================
function results = simulate_vision_system(defects, params, is_adaptive, base_detection)
    num_samples = length(defects);
    detected = false(num_samples, 1);
    exposure_issues = false(num_samples, 1);
    processing_times = zeros(num_samples, 1);
    
    % Initialize adaptive parameters
    if is_adaptive
        current_exposure = 500; % Initial exposure time(μs)
        current_light = 100;    % Initial light source intensity(%)
    end
    
    for i = 1:num_samples
        % Processing time simulation
        if is_adaptive
            processing_times(i) = 0.9 + 0.2*rand(); % Adaptive mode is faster
        else
            processing_times(i) = 1.1 + 0.2*rand(); % Fixed mode is slower
        end
        
        % Defect detection simulation
        if defects(i)
            % Real defect
            if is_adaptive
                % Adaptive detection logic
                detection_prob = base_detection + 0.1 * (1 - abs(current_exposure - 550)/550);
                detected(i) = rand() < detection_prob;
                
                % Exposure issue detection
                exposure_issues(i) = rand() < 0.05 * abs(current_exposure - 550)/550;
                
                % Parameter adaptive update
                if i > params.window_size
                    window_defects = defects(i-params.window_size:i);
                    window_detected = detected(i-params.window_size:i);
                    detection_rate = sum(window_detected) / sum(window_defects);
                    
                    % Simple adjustment rule
                    if detection_rate < 0.92
                        current_exposure = current_exposure + params.learning_rate * (550 - current_exposure);
                    end
                end
            else
                % Fixed parameter detection
                detected(i) = rand() < base_detection;
                exposure_issues(i) = rand() < 0.12;
            end
        else
            % Non-defective sample
            detected(i) = false;
            exposure_issues(i) = false;
        end
    end
    
    % Calculate results
    results = struct();
    results.detection_rate = sum(detected(defects)) / sum(defects);
    results.exposure_issues = mean(exposure_issues);
    results.processing_time = mean(processing_times);
end